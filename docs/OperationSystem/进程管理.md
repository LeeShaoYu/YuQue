# 进程



## 进程的基本状态



## 进程调度

### 上下文切换



### 调度种类

- 高级调度
- 中级调度
- 低级调度

### 非抢占式调度与抢占式调度

- 非抢占式
- 抢占式

### 调度策略的设计

- 响应时间
- 周转时间
- 平均周转时间
- 

### 调度算法

1. FCFS
2. SJF
3. HRN
4. 优先权调度
5. Round-Robin(RR)
6. 多级队列调度
7. 多级反馈队列

## 进程同步

### 临界资源与临界区

### 信号量

### 锁

- **互斥锁**
- **自旋锁**
- **读写锁**
- **阻塞锁**

- **可重入锁**
- **公平锁**
- **非公平锁**
- **悲观锁**
- **乐观锁**

### 死锁



#### 死锁产生的四个必要条件



#### 死锁避免

银行家算法

### CAS

**比较并交换(compare and swap, CAS)**

## 进程间通信

本地进程间通信的方式有很多，可以总结为下面四类：

- 消息传递（管道、FIFO、消息队列）
- 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）
- 共享内存（匿名的和具名的）
- 远程过程调用（Solaris门和Sun RPC）

## 子进程



# 线程



## 线程的属性



## 进程 vs 线程

**线程本质就是堆栈**，当一段程序在执行，能代表它的是他的过去和现在。*过去* 在堆栈中，*现在* 则是 CPU 的所有寄存器，如果我们要挂起一个线程，我们把寄存器也保存到堆栈中，我们就具有它的所有状态，可以随时恢复它。

**进程的本质是地址空间**，当我们切换线程的时候，同时切换它的地址空间（通过修改MMU即可），则认为发生了进程切换。

# 中断



## 硬件中断

- **外中断**
- **内中断**

## 软件中断



# 内核态&用户态

**内核态是一种 CPU 的特权态**

### 内核态切换

