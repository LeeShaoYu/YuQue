## 如何实现本地缓存和分布式缓存？

缓存（Cache） 是指将程序或系统中常用的数据对象存储在像内存这样特定的介质中，以避免在每次程序调用时，重新创建或组织数据所带来的性能损耗，从而提高了系统的整体运行速度。

以目前的系统架构来说，用户的请求一般会先经过缓存系统，如果缓存中没有相关的数据，就会在其他系统中查询到相应的数据并保存在缓存中，最后返回给调用方。

本地缓存是指程序级别的缓存组件，它的特点是本地缓存和应用程序会运行在同一个进程中，所以本地缓存的操作会非常快，因为在同一个进程内也意味着不会有网络上的延迟和开销。

本地缓存适用于单节点非集群的应用场景，它的优点是快，缺点是多程序无法共享缓存，比如分布式用户 Session 会话信息保存，由于每次用户访问的服务器可能是不同的，如果不能共享缓存，那么就意味着每次的请求操作都有可能被系统阻止，因为会话信息只保存在某一个服务器上，当请求没有被转发到这台存储了用户信息的服务器时，就会被认为是非登录的违规操作。

除此之外，无法共享缓存可能会造成系统资源的浪费，这是因为每个系统都单独维护了一份属于自己的缓存，而同一份缓存有可能被多个系统单独进行存储，从而浪费了系统资源。

**分布式缓存**是指将应用系统和缓存组件进行分离的缓存机制，这样多个应用系统就可以共享一套缓存数据了，它的特点是共享缓存服务和可集群部署，为缓存系统提供了高可用的运行环境，以及缓存共享的程序运行机制。

本地缓存可以使用 EhCache 和 Google 的 Guava 来实现，而分布式缓存可以使用 Redis 或 Memcached 来实现。

### 手动实现一个缓存系统

要自定义一个缓存，首先要考虑的是数据类型，我们可以使用 Map 集合中的 HashMap、Hashtable 或 ConcurrentHashMap 来实现，非并发情况下我们可以使用 HashMap，并发情况下可以使用 Hashtable 或 ConcurrentHashMap，由于 ConcurrentHashMap 的性能比 Hashtable 的高，因此在高并发环境下我们可以倾向于选择 ConcurrentHashMap，不过它们对元素的操作都是类似的。

选定了数据类型之后，我们还需要考虑缓存过期和缓存淘汰等问题，在这里我们可以借鉴 Redis 对待过期键的处理策略。

目前比较常见的过期策略有以下三种：

- 定时删除

- 惰性删除

- 定期删除

  定时删除是指在设置键值的过期时间时，创建一个定时事件，当到达过期时间后，事件处理器会执行删除过期键的操作。它的优点是可以及时的释放内存空间，缺点是需要开启多个延迟执行事件来处理清除任务，这样就会造成大量任务事件堆积，占用了很多系统资源。

  惰性删除不会主动删除过期键，而是在每次请求时才会判断此值是否过期，如果过期则删除键值，否则就返回 null。它的优点是只会占用少量的系统资源，缺点是清除不够及时，会造成一定的空间浪费。

  定期删除是指每隔一段时间检查一次数据库，随机删除一些过期键值。

Redis 使用的是定期删除和惰性删除这两种策略；

先来说一下自定义缓存的实现思路，首先需要定义一个存放缓存值的实体类，这个类里包含了缓存的相关信息，比如缓存的 key 和 value，缓存的存入时间、最后使用时间和命中次数（预留字段，用于支持 LFU 缓存淘汰），再使用 ConcurrentHashMap 保存缓存的 key 和 value 对象（缓存值的实体类），然后再新增一个缓存操作的工具类，用于添加和删除缓存，最后再缓存启动时，开启一个无限循环的线程用于检测并删除过期的缓存，