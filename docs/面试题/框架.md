## 消息队列的使用场景有哪些？如何手动实现一个消息队列和延迟消息队列？

消息队列的使用场景有很多，最常见的使用场景有以下几个：

- 削峰
- 填谷

**消息队列的特点**：

- 先进先出：消息队列的顺序一般在入列时就基本确定了，最先到达消息队列的信息，一般情况下也会先转发给订阅的消费者，我们把这种实现了先进先出的数据结构称之为队列。
- 发布、订阅工作模式：生产者也就是消息的创建者，负责创建和推送数据到消息服务器；消费者也就是消息的接收方，用于处理数据和确认消息的消费；消息队列也是 MQ 服务器中最重要的组成元素之一，它负责消息的存储，这三者是 MQ 中的三个重要角色。而它们之间的消息传递与转发都是通过发布以及订阅的工作模式来进行的，即生产者把消息推送到消息队列，消费者订阅到相关的消息后进行消费，在消息非阻塞的情况下，此模式基本可以实现同步操作的效果。并且此种工作模式会把请求的压力转移给 MQ 服务器，以减少了应用服务器本身的并发压力。
- 持久化：持久化是把消息从内存存储到磁盘的过程，并且在服务器重启或者发生宕机的情况下，重新启动服务器之后是保证数据不会丢失的一种手段，也是目前主流 MQ 中间件都会提供的重要功能。
- 分布式：MQ 的一个主要特性就是要应对大流量、大数据的高并发环境，一个单体的 MQ 服务器是很难应对这种高并发的压力的，所以 MQ 服务器都会支持分布式应用的部署，以分摊和降低高并发对 MQ 系统的冲击。
- 消息确认：消息消费确认是程序稳定性和安全性的一个重要考核指标，假如消费者在拿到消息之后突然宕机了，那么 MQ 服务器会误认为此消息已经被消费者消费了，从而造成消息丢失的问题，而目前市面上的主流 MQ 都实现了消息确认的功能，保证了消息不会丢失，从而保证了系统的稳定性。

**使用消息队列可能会带来的问题**：

- 增加了系统的运行风险：引入 MQ 系统，则意味着新增了一套系统，并且其他的业务系统会对 MQ 系统进行深度依赖，系统部署的越多则意味着发生故障的可能性就越大，如果 MQ 系统挂掉的话可能会导致整个业务系统瘫痪。
- 增加了系统的复杂度：引入 MQ 系统后，需要考虑消息丢失、消息重复消费、消息的顺序消费等问题，同时还需要引入新的客户端来处理 MQ 的业务，增加了编程的运维门槛，增加了系统的复杂性。

我们可以通过 JDK 提供的 Queue 来实现自定义消息队列，使用 DelayQueue 实现延迟消息队列。

## Spring Bean 的作用域有哪些？它的注册方式有几种？

在 Spring 容器中管理一个或多个 Bean，这些 Bean 的定义表示为 BeanDefinition 对象，这些对象包含以下重要信息：

- Bean 的实际实现类

- Bean 的作用范围

- Bean 的引用或者依赖项

Bean 的注册方式有三种：

- XML 配置文件的注册方式

- Java 注解的注册方式

- Java API 的注册方式

  使用 BeanDefinitionRegistry.registerBeanDefinition() 方法的方式注册 Bean;

Bean 的作用域一共有 5 个：

- **singleton 作用域**：表示在 Spring 容器中只有一个 Bean 实例，以单例的形式存在，是默认的 Bean 作用域。
- **prototype 作用域**：原型作用域，每次调用 Bean 时都会创建一个新实例，也就是说每次调用 getBean() 方法时，相当于执行了 new Bean()。
- **request 作用域**：每次 Http 请求时都会创建一个新的 Bean，该作用域仅适应于 WebApplicationContext 环境。
- **session 作用域**：同一个 Http Session 共享一个 Bean 对象，不同的 Session 拥有不同的 Bean 对象，仅适用于 WebApplicationContext 环境。
- **application 作用域**：全局的 Web 作用域，类似于 Servlet 中的 Application。



## 同名 Bean 问题

同一个 Spring 配置文件中 Bean 的 id 和 name 是不能够重复的，否则 Spring 容器启动时会报错。但如果 Spring 加载了多个配置文件的话，可能会出现同名 Bean 的问题。同名 Bean 指的是多个 Bean 有相同的 name 或者 id。

Spring 对待同名 Bean 的处理规则是使用最后面的 Bean 覆盖前面的 Bean，所以我们在定义 Bean 时，尽量使用长命名非重复的方式来定义，避免产生同名 Bean 的问题。

Bean 的 id 或 name 属性并非必须指定，如果留空的话，容器会为 Bean 自动生成一个唯一的名称，这样也不会出现同名 Bean 的问题。

## Bean 生命周期

对于 Spring Bean 来说，并不是启动阶段就会触发 Bean 的实例化，只有当客户端通过显式或者隐式的方式调用 BeanFactory 的 getBean() 方法时，它才会触发该类的实例化方法。当然对于 BeanFactory 来说，也不是所有的 getBean() 方法都会实例化 Bean 对象，例如作用域为 singleton 时，只会在第一次，实例化该 Bean 对象，之后会直接返回该对象。但如果使用的是 ApplicationContext 容器，则会在该容器启动的时候，立即调用注册到该容器所有 Bean 的实例化方法。
![img](https://s0.lgstatic.com/i/image3/M01/89/0C/Cgq2xl6WvHqAdmt4AABGAn2eSiI631.png)

## 谈一谈你对 IoC 和 DI 的理解。

**IoC**（Inversion of Control，翻译为“控制反转”）不是一个具体的技术，而是一种设计思想。与传统控制流相比，IoC 会颠倒控制流，在传统的编程中需要开发者自行创建并销毁对象，而在 IoC 中会把这些操作交给框架来处理，这样开发者就不用关注具体的实现细节了，拿来直接用就可以了，这就是控制反转。

IoC 很好的体现出了面向对象的设计法则之一——好莱坞法则：“别找我们，我们找你”。即由 IoC 容器帮对象找到相应的依赖对象并注入，而不是由对象主动去找。

**DI**（Dependency Injection，翻译为“依赖注入”）表示组件间的依赖关系交由容器在运行期自动生成，也就是说，由容器动态的将某个依赖关系注入到组件之中，这样就能提升组件的重用频率。通过依赖注入机制，我们只需要通过简单的配置，就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心资源来自哪里、由谁实现等问题。

**被注入对象依赖 IoC 容器配置依赖对象**



## Spring IoC 有哪些优势？

IoC 的优点有以下几个：

- 使用更方便，拿来即用，无需显式的创建和销毁的过程；
- 可以很容易提供众多服务，比如事务管理、消息服务等；
- 提供了单例模式的支持；
- 提供了 AOP 抽象，利用它很容易实现权限拦截、运行期监控等功能；
- 更符合面向对象的设计法则；
- 低侵入式设计，代码的污染极低，降低了业务对象替换的复杂性。

## IoC 的注入方式有哪些？

IoC 的注入方式有三种：构造方法注入、Setter 注入和接口注入。

## 谈一谈你对 AOP 的理解。

**AOP**（Aspect-OrientedProgramming，面向切面编程）可以说是 OOP（Object-Oriented Programing，面向对象编程）的补充和完善，OOP 引入封装、继承和多态性等概念来建立一种公共对象处理的能力，当我们需要处理公共行为的时候，OOP 就会显得无能为力，而 AOP 的出现正好解决了这个问题。比如统一的日志处理模块、授权验证模块等都可以使用 AOP 很轻松的处理。

Spring AOP 目前提供了三种配置方式：

- 基于 Java API 的方式；
- 基于 @AspectJ（Java）注解的方式；
- 基于 XML <aop /> 标签的方式。

## MyBatis 使用了哪些设计模式？在源码中是如何体现的？

- 工厂模式

  工厂模式在 MyBatis 中的典型代表是 SqlSessionFactory。

  SqlSession 是 MyBatis 中的重要 Java 接口，可以通过该接口来执行 SQL 命令、获取映射器示例和管理事务，而 SqlSessionFactory 正是用来产生 SqlSession 对象的，所以它在 MyBatis 中是比较核心的接口之一。

- 建造者模式（Builder）

  建造者模式指的是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。也就是说建造者模式是通过多个模块一步步实现了对象的构建，相同的构建过程可以创建不同的产品。

  建造者模式在 MyBatis 中的典型代表是 SqlSessionFactoryBuilder。

  普通的对象都是通过 new 关键字直接创建的，但是如果创建对象需要的构造参数很多，且不能保证每个参数都是正确的或者不能一次性得到构建所需的所有参数，那么就需要将构建逻辑从对象本身抽离出来，让对象只关注功能，把构建交给构建类，这样可以简化对象的构建，也可以达到分步构建对象的目的，而 SqlSessionFactoryBuilder 的构建过程正是如此。

- 单例模式

  单例模式在 MyBatis 中的典型代表是 ErrorContext。

  ErrorContext 是线程级别的的单例，每个线程中有一个此对象的单例，用于记录该线程的执行环境的错误信息。

- 适配器模式

  适配器模式在 MyBatis 中的典型代表是 Log。

  MyBatis 中的日志模块适配了以下多种日志类型：

  - SLF4J
  - Apache Commons Logging
  - Log4j 2
  - Log4j
  - JDK logging

- 代理模式

  代理模式指的是给某一个对象提供一个代理对象，并由代理对象控制原对象的调用。

  代理模式在 MyBatis 中的典型代表是 MapperProxyFactory。

  MapperProxyFactory 的 newInstance() 方法就是生成一个具体的代理来实现功能的；

- 模板方法模式

  模板方法模式是最常用的设计模式之一，它是指定义一个操作算法的骨架，而将一些步骤的实现延迟到子类中去实现，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。此模式是基于继承的思想实现代码复用的。

  模板方法在 MyBatis 中的典型代表是 BaseExecutor。

  在 MyBatis 中 BaseExecutor 实现了大部分 SQL 执行的逻辑，然后再把几个方法交给子类来实现；

- 装饰器模式

  装饰器模式在 MyBatis 中的典型代表是 Cache。

  Cache 除了有数据存储和缓存的基本功能外（由 PerpetualCache 永久缓存实现），还有其他附加的 Cache 类，比如先进先出的 FifoCache、最近最少使用的 LruCache、防止多线程并发访问的 SynchronizedCache 等众多附加功能的缓存类；



## SpringBoot 有哪些优点？它和 Spring 有什么区别？

Spring Boot 本质上是 Spring 框架的延伸和扩展，它的诞生是为了简化 Spring 框架初始搭建以及开发的过程，使用它可以不再依赖 Spring 应用程序中的 XML 配置，为更快、更高效的开发 Spring 提供更加有力的支持。Spring Boot 具体的特性如下。

- 更快速的构建能力
- 基础依赖
- 内嵌容器支持
- Actuator 监控

## Spring Boot 的启动流程

1. 创建并启动计时监控类

   此计时器是为了监控并记录 Spring Boot 应用启动的时间的，它会记录当前任务的名称，然后开启计时器。

2. 声明应用上下文对象和异常报告集合

   此过程声明了应用上下文对象和一个异常报告的 ArrayList 集合。

3. 设置系统属性 headless 的值

   设置 Java.awt.headless = true，其中 awt（Abstract Window Toolkit）的含义是抽象窗口工具集。设置为 true 表示运行一个 headless 服务器，可以用它来作一些简单的图像处理。

4. 创建所有 Spring 运行监听器并发布应用启动事件

   此过程用于获取配置的监听器名称并实例化所有的类。

5. 初始化默认应用的参数类

   也就是说声明并创建一个应用参数对象。

6. 准备环境

   创建配置并且绑定环境（通过 property sources 和 profiles 等配置文件）。

7. 创建 Banner 的打印类

   Spring Boot 启动时会打印 Banner 图片：

   此 banner 信息是在 SpringBootBanner 类中定义的，我们可以通过实现 Banner 接口来自定义 banner 信息，然后通过代码 setBanner() 方法设置 Spring Boot 项目使用自己自定义 Banner 信息，或者是在 resources 下添加一个 banner.txt，把 banner 信息添加到此文件中，就可以实现自定义 banner 的功能了。

8. 创建应用上下文

   根据不同的应用类型来创建不同的 ApplicationContext 上下文对象。

9. 实例化异常报告器

   它调用的是 getSpringFactoriesInstances() 方法来获取配置异常类的名称，并实例化所有的异常处理类。

10. 准备应用上下文

    此方法的主要作用是把上面已经创建好的对象，传递给 prepareContext 来准备上下文，例如将环境变量 environment 对象绑定到上下文中、配置 bean 生成器以及资源加载器、记录启动日志等操作。

11. 刷新应用上下文

    此方法用于解析配置文件，加载 bean 对象，并且启动内置的 web 容器等操作。

12. 应用上下文刷新之后的事件处理

    这个方法的源码是空的，可以做一些自定义的后置处理操作。

13. 停止计时监控类

    停止此过程第一步中的程序计时器，并统计任务的执行信息。

14. 输出日志信息

    把相关的记录信息，如类名、时间等信息进行控制台输出。

15. 发布应用上下文启动完成事件

    触发所有 SpringApplicationRunListener 监听器的 started 事件方法。

16. 执行所有 Runner 运行器

    执行所有的 ApplicationRunner 和 CommandLineRunner 运行器。

17. 发布应用上下文就绪事件

    触发所有的 SpringApplicationRunListener 监听器的 running 事件。

18. 返回应用上下文对象

    到此为止 Spring Boot 的启动程序就结束了，我们就可以正常来使用 Spring Boot 框架了。