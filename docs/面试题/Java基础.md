、

# Java基础面向对象的特征

## 面向对象的特征

   面向对象的三个基本特征是：封装、继承、多态。

- 封装

  封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

- 继承

  面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

- 多态

  多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。 实现多态，有二种方式，覆盖，重载。

##  final, finally, finalize 的区别

- final

  用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.

- finally

  是异常处理语句结构的一部分，表示总是执行.

- finally

  是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.

##  int和Integer有什么区别？(包装类与基本数据类型的区别)

   int 是 Java 提供的 8 种原始数据类型之一。Java 为每个原始类型提供了封装类，Integer 是 Java 为 int 提供的封装类。 int 的默认值为 `0`，而 Integer 的默认值为 `null`，是引用类型，即 Integer 可以区分出未赋值和值为 0 的区别，int 则无法表达出未赋值的情况， Java 中 int 和 Integer 关系是比较微妙的。关系如下：

   - int 是基本的数据类型；
   - Integer 是 int 的封装类；
   - int 和 Integer 都可以表示某一个数值；
   - int 和 Integer 不能够互用，因为他们两种不同的数据类型；

##  重载与重写的区别？

   - 重载overload

     表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）

   - 重写override

     表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。

##  抽象类与接口的区别？

| 参数                 | 抽象类                                                       | 接口                                                         |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 默认的方法实现       | 它可以有默认的方法实现                                       | 接口完全是抽象的。它根本不存在方法的实现                     |
| 实现                 | 子类使用 extends 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 | 子类使用关键字 implements 来实现接口。它需要提供接口中所有声明的方法的实现 |
| 构造器               | 抽象类可以有构造器                                           | 接口不能有构造器                                             |
| 与正常 Java 类的区别 | 除了你不能实例化抽象类之外，它和普通Java类没有任何区别       | 接口是完全不同的类型                                         |
| 访问修饰符           | 抽象方法可以有 public、protected 和 default 这些修饰符       | 接口方法默认修饰符是 public。你不可以使用其它修饰符。        |
| main 方法            | 抽象方法可以有 main 方法并且我们可以运行它                   | 接口没有 main 方法，因此我们不能运行它。                     |
| 多继承               | 抽象方法可以继承一个类和实现多个接口                         | 接口只可以继承一个或多个其它接口                             |
| 速度                 | 它比接口速度要快                                             | 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。   |
| 添加新方法           | 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 | 如果你往接口中添加方法，那么你必须改变实现该接口的类。       |

##  说说反射的用途与实现？

   - 用途

     Java 反射机制是一个非常强大的功能，在很多的项目比如 Spring，MyBatis 都都可以看到反射的身影。**通过反射机制，我们可以在运行期间获取对象的类型信息。**利用这一点我们可以实现工厂模式和代理模式等设计模式，同时也可以解决 Java 泛型擦除等令人苦恼的问题。

   - 实现

     获取一个对象对应的反射类，在 Java 中有下列方法可以获取一个对象的反射类

     1.  通过 `getClass()` 方法
     2.  通过 `Class.forName()` 方法
     3.  使用 `类.class`
     4.  通过类加载器实现，`getClassLoader()`

##  说说自定义注解的场景与实现？

   登陆、权限拦截、日志处理，以及各种 Java 框架，如 Spring，Hibernate，JUnit 提到注解就不能不说反射，Java 自定义注解是通过运行时靠反射获取注解。实际开发中，例如我们要获取某个方法的调用日志，可以通过 AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含日志注解，就进行日志记录。反射的实现在 Java 应用层面上讲，是通过对 Class 对象的操作实现的，Class 对象为我们提供了一系列方法对类进行操作。在 JVM 这个角度来说，Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目按严格的顺序紧凑的排列在 Class 文件中，里面包含了类、方法、字段等等相关数据。通过对 Class 数据流的处理我们即可得到字段、方法等数据。

##  HTTP请求中的GET和POST的区别？

   - 根据 HTTP 规范，GET 用于信息获取，而且应该是安全的和幂等的，首先是 "GET 方式提交的数据最多只能是 1024 字节"，因为 GET 是通过 URL 提交数据，那么 GET 可提交的数据量就跟 URL 的长度有直接关系了。而实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE 对 URL 长度的限制是 2083 字节(2K+35)。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个 URL 长度，而不仅仅是你的参数值数据长度。。
   - 根据 HTTP 规范，POST 表示可能修改变服务器上的资源的请求。POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制

##  session与cookie的区别？

   - cookie 数据存放在客户的浏览器上，session 数据放在服务器上。
   - cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗，考虑到安全应当使用 session。
   - session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 cookie。
   - 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。

##  session分布式处理？
- ##### Session 复制

  在支持 Session 复制的 Web 服务器上，通过修改 Web 服务器的配置，可以实现将 Session 同步到其它 Web 服务器上，达到每个 Web 服务器上都保存一致的 Session。

  - 优点：代码上不需要做支持和修改。
  - 缺点：需要依赖支持的 Web 服务器，一旦更换成不支持的 Web 服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，而且会导致延迟。
  - 适用场景：只适用于Web服务器比较少且 Session 数据量少的情况。
  - 可用方案：开源方案 tomcat-redis-session-manager，暂不支持 Tomcat8。

- ##### Session 粘滞

      将用户的每次请求都通过某种方法强制分发到某一个 Web 服务器上，只要这个 Web 服务器上存储了对应 Session 数据，就可以实现会话跟踪。
        
      -  优点：使用简单，没有额外开销。
      -  缺点：一旦某个 Web 服务器重启或宕机，相对应的 Session 数据将会丢失，而且需要依赖负载均衡机制。
      -  适用场景：对稳定性要求不是很高的业务情景。

    - ##### Session 集中管理

      在单独的服务器或服务器集群上使用缓存技术，如 Redis 存储 Session 数据，集中管理所有的 Session，所有的Web服务器都从这个存储介质中存取对应的 Session，实现 Session 共享。

      - 优点：可靠性高，减少 Web 服务器的资源开销。
      - 缺点：实现上有些复杂，配置较多。
      - 适用场景：Web服务器较多、要求高可用性的情况。
      - 可用方案：开源方案 Spring Session，也可以自己实现，主要是重写 HttpServletRequestWrapper 中的 getSession 方法。

    - ##### 基于 Cookie 管理

      这种方式每次发起请求的时候都需要将 Session 数据放到 Cookie 中传递给服务端。

      - 优点：不需要依赖额外外部存储，不需要额外配置。
      - 缺点：不安全，易被盗取或篡改；Cookie 数量和长度有限制，需要消耗更多网络带宽。
      - 适用场景：数据不重要、不敏感且数据量小的情况。

      这四种方式，相对来说，**Session 集中管理** 更加可靠，使用也是最多的。

## JDBC流程

- 向 DriverManager 类注册驱动数据库驱动程序
- 调用 DriverManager.getConnection 方法， 通过 JDBC URL，用户名，密码取得数据库连接的 Connection 对象。
- 获取 Connection 后， 便可以通过 createStatement 创建 Statement 用以执行 SQL 语句。
- 有时候会得到查询结果，比如 select，得到查询结果，查询（SELECT）的结果存放于结果集（ResultSet）中。
- 关闭数据库语句，关闭数据库连接。

##  MVC思想

MVC 是三个单词的首字母缩写，它们是 Model（模型）、View（视图）和 Controller（控制）。 这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层：

- 最上面的一层，是直接面向最终用户的"视图层"（View）。它是提供给用户的操作界面，是程序的外壳。
- 最底下的一层，是核心的"数据层"（Model），也就是程序需要操作的数据或信息。
- 中间的一层，就是"控制层"（Controller），它负责根据用户从"视图层"输入的指令，选取"数据层"中的数据，然后对其进行相应的操作，产生最终结果。

##  equals和 ==的区别？

- `==` 与`equals` 的主要区别是：`==` 常用于比较原生类型，而 `equals()` 方法用于检查对象的相等性。
- 另一个不同的点是：如果 `==` 和 `equals()` 用于比较对象，当两个引用地址相同，`==` 返回 true。而 `equals()` 可以返回 true 或者 false 主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况 `==` 和 `equals()` 返回不同的结果。

## 深克隆和浅克隆有什么区别？它的实现方式有哪些？

- 浅克隆（Shadow Clone）是把原型对象中成员变量为值类型的属性都复制给克隆对象，把原型对象中成员变量为引用类型的引用地址也复制给克隆对象，也就是原型对象中如果有成员变量为引用对象，则此引用对象的地址是共享给原型对象和克隆对象的；

- 深克隆（Deep Clone）是将原型对象中的所有类型，无论是值类型还是引用类型，都复制一份给克隆对象，也就是说深克隆会把原型对象和原型对象所引用的对象，都复制一份给克隆对象；

  - 在 java.lang.Object 中对 clone() 方法的约定有哪些？

    - 对于所有对象来说，x.clone() !=x 应当返回 true，因为克隆对象与原对象不是同一个对象；
    - 对于所有对象来说，x.clone().getClass() == x.getClass() 应当返回 true，因为克隆对象与原对象的类型是一样的；
    - 对于所有对象来说，x.clone().equals(x) 应当返回 true，因为使用 equals 比较时，它们的值都是相同的。

  - Arrays.copyOf() 是深克隆还是浅克隆？

    因为数组比较特殊数组本身就是引用类型，因此在使用 Arrays.copyOf() 其实只是把引用地址复制了一份给克隆对象，如果修改了它的引用对象，那么指向它的（引用地址）所有对象都会发生改变，因此看到的结果是，修改了克隆对象的第一个元素，原型对象也跟着被修改了。

  - 深克隆的实现方式有几种？

    - 所有对象都实现克隆方法；
    - 通过构造方法实现深克隆；
    - 使用 JDK 自带的字节流实现深克隆；
    - 使用第三方工具实现深克隆，比如 Apache Commons Lang；
    - 使用 JSON 工具类实现深克隆，比如 Gson、FastJSON 等。

  - Java 中的克隆为什么要设计成，既要实现空接口 Cloneable，还要重写 Object 的 clone() 方法？



## 动态代理是如何实现的？JDK Proxy 和 CGLib 有什么区别？

动态代理是程序在运行期间动态构建代理对象和动态调用代理方法的一种机制。

动态代理的常用实现方式是反射。反射机制是指程序在运行期间可以访问、检测和修改其本身状态或行为的一种能力，使用反射我们可以调用任意一个类对象，以及类对象中包含的属性及方法。

JDK Proxy 和 CGLib 的区别主要体现在以下几个方面：

- JDK Proxy 是 Java 语言自带的功能，无需通过加载第三方类实现；
- Java 对 JDK Proxy 提供了稳定的支持，并且会持续的升级和更新 JDK Proxy，例
- 如 Java 8 版本中的 JDK Proxy 性能相比于之前版本提升了很多；
- JDK Proxy 是通过拦截器加反射的方式实现的；
- JDK Proxy 只能代理继承接口的类；
- JDK Proxy 实现和调用起来比较简单；
- CGLib 是第三方提供的工具，基于 ASM 实现的，性能比较高；
- CGLib 无需通过接口来实现，它是通过实现子类的方式来完成调用的。

## 你对 JDK Proxy 和 CGLib 的掌握程度

JDK Proxy 动态代理的实现无需引用第三方类，只需要实现 InvocationHandler 接口，重写 invoke() 方法即可；

 CGLib 和 JDK Proxy 的实现代码比较类似，都是通过实现代理器的接口，再调用某一个方法完成动态代理的，唯一不同的是，CGLib 在初始化被代理类时，是通过 Enhancer 对象把代理对象设置为被代理类的子类来实现动态代理的。因此被代理类不能被关键字 final 修饰，如果被 final 修饰，再使用 Enhancer 设置父类时会报错，动态代理的构建会失败。

## Lombok 是通过反射实现的吗？

在编译期阶段，当 Java 源码被抽象成语法树（AST）之后，Lombok 会根据自己的注解处理器动态修改 AST，增加新的代码（节点），在这一切执行之后就生成了最终的字节码（.class）文件，这就是 Lombok 的执行原理。

## 动态代理和静态代理有什么区别？动态代理的使用场景有哪些？Spring 中的动态代理是通过什么方式实现的？

静态代理其实就是事先写好代理类，可以手工编写也可以使用工具生成，但它的缺点是每个业务类都要对应一个代理类，特别不灵活也不方便，于是就有了动态代理。

动态代理的常见使用场景有 RPC 框架的封装、AOP（面向切面编程）的实现、JDBC 的连接等。

Spring 框架中同时使用了两种动态代理 JDK Proxy 和 CGLib，当 Bean 实现了接口时，Spring 就会使用 JDK Proxy，在没有实现接口时就会使用 CGLib，我们也可以在配置中指定强制使用 CGLib，只需要在 Spring 配置中添加 <aop:aspectj-autoproxy proxy-target-class="true"/> 即可。

## 

## 

